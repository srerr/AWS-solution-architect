#AWS IAM:
--------
1)Users: 
  - An IAM user is an entity that you create in AWS to represent the person or application that uses it to interact with AWS.
  - A user in AWS consists of a name and credentials.   
  - Users can be assigned individual security credentials such as access keys, passwords, and multi-factor authentication devices.
  - Users can be organized into groups to simplify the management of permissions. 
  - Users can be granted permissions either directly or through group membership.
2)Groups:
  - An IAM group is a collection of IAM users.      
    - Groups let you specify permissions for multiple users, which can make it easier to manage the permissions for those users.
    - When you assign a permission to a group, all users in that group inherit the permissions assigned to the group.
    - Groups cannot be nested, meaning you cannot create a group within another group.
3)Roles:
    - An IAM role is an AWS identity with specific permissions.
        - Roles are intended to be assumable by anyone who needs them, including IAM users, applications, or AWS services.
        - Roles do not have long-term credentials (password or access keys) associated with them. Instead, when you assume a role, it provides temporary security credentials for your session.
        - Roles are commonly used for granting permissions to AWS services to perform actions on your behalf, such as allowing an EC2 instance to access S3 buckets.    
4)Policies:
    - An IAM policy is a JSON document that defines permissions for an action or set of actions on AWS resources.
        - Policies can be attached to users, groups, or roles to define what actions they are allowed or denied to perform.
        - Policies consist of one or more statements, each of which includes:
            - Effect: Specifies whether the statement allows or denies access (Allow or Deny).
            - Action: Specifies the AWS service actions that are allowed or denied.
            - Resource: Specifies the AWS resources to which the actions apply.
        - There are two types of policies: managed policies (created and managed by AWS or by you) and inline policies (embedded directly into a user, group, or role). 
5)Identity Federation:
    - Identity federation allows users to access AWS resources using external identities, such as those from corporate directories or social identity providers (like Google or Facebook).
        - This is typically achieved using SAML (Security Assertion Markup Language) or OpenID Connect (OIDC) protocols.
        - With identity federation, users can sign in to AWS without needing to create an IAM user for each individual. 
6)Resource-Based Policies:
    - Resource-based policies are policies that you attach directly to AWS resources, such as S3 buckets or SNS topics.
        - These policies specify who (which users or roles) can access the resource and what actions they can perform on it.
        - Resource-based policies are useful for granting cross-account access, allowing users from different AWS accounts to access resources securely.    
7)Multi-Factor Authentication (MFA):
    - MFA is an additional layer of security for your AWS accounts and IAM users.
        - With MFA enabled, users must provide two or more forms of authentication to access AWS resources: something they know (like a password) and something they have (like a physical or virtual MFA device).
        - MFA helps protect against unauthorized access, especially in cases where user credentials may be compromised. 
8)AWS Organizations and IAM:
    - AWS Organizations is a service that allows you to centrally manage and govern multiple AWS accounts.
        - When using AWS Organizations, you can apply Service Control Policies (SCPs) to restrict the permissions that IAM users and roles in member accounts can have.
        - SCPs help enforce compliance and security policies across all accounts in the organization.   

#IAM Policy Deep Dive:
----------------------
->anotomy of a policy:
{
  "Version": "2012-10-17",                //policy language version
  "Statement": [                         //array of individual statements
    {
      "Effect": "Allow" | "Deny",        //whether the statement allows or denies access
      "Action": "service:action" | [     //list of actions that are allowed or denied
        "service:action1",
        "service:action2"
      ],
      "Resource": "arn:aws:service:region:account-id:resource" | [  //list of resources the actions apply to
        "arn:aws:service:region:account-id:resource1",
        "arn:aws:service:region:account-id:resource2"
      ],
      "Condition": {                      //optional conditions for when the policy is in effect
        "condition-operator": {
          "condition-key": "condition-value"
        }
      }
    }
  ]
}
->Policy Evaluation Logic:
  - By default, all requests are denied.
  - An explicit allow overrides the default deny.
  - An explicit deny overrides any allow.
    - If there is no explicit allow or deny, the request is denied. 
->Types of Policies:
  1)Managed Policies:
    - AWS Managed Policies: Created and managed by AWS, designed to provide permissions for common use cases.
    - Customer Managed Policies: Created and managed by you, allowing for more granular control over permissions.   
    Example managed policies:
    - AdministratorAccess: Provides full access to all AWS services and resources.
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Action": "*",
              "Resource": "*"
            }
          ]
        }
    - PowerUserAccess: Provides full access to AWS services and resources, but does not allow management of users and groups.
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "*"
              ],
              "Resource": "*",
              "Condition": {
                "StringNotEquals": {
                  "iam:PermissionsBoundary": "arn:aws:iam::aws:policy/AdministratorAccess"
                }
              }
            }
          ]
        }
    
   2)Inline Policies:
    - Embedded directly into a single user, group, or role.
    - Useful for specific permissions that should not be shared across multiple entities.   

# IAM Policies: Conditions
--------------------------
->Condition Element:
  - The Condition element in an IAM policy allows you to specify additional constraints that must be met for the policy to take effect.
  - Conditions are expressed as key-value pairs, where the key is a condition operator and the value is the condition key and its expected value.
    - Common condition operators include StringEquals, NumericLessThan, Bool, IpAddress, and DateGreaterThan.   
->Example Condition:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:ListBucket",
      "Resource": "arn:aws:s3:::example-bucket",
      "Condition": {
        "IpAddress": {
          "aws:SourceIp": "203.0.113.0/24"
        }
      }
    }
  ]
}
  - In this example, the policy allows the ListBucket action on the specified S3 bucket only if the request originates from the IP address range 203.0.113.0/24.
->Common Use Cases for Conditions:
  - Restricting access based on IP address or VPC endpoint.
    - Enforcing MFA for sensitive operations.
    - Limiting access to specific times of day or dates.
    - Controlling access based on the presence of specific tags on resources or users.
->Best Practices for Using Conditions:
  - Use conditions to implement the principle of least privilege, granting only the necessary permissions under specific circumstances.
  - Regularly review and update conditions to ensure they align with your security policies and requirements.   
    - Test policies with conditions in a safe environment to verify they behave as expected before deploying them in production.        

#IAM Policies Variables and Tags:
----------------------------------
->Policy Variables:
  - Policy variables are placeholders that can be used in IAM policies to create dynamic and reusable policies.
  - They are denoted by the ${variable_name} syntax and are replaced with actual values when the policy is evaluated.
    - Common policy variables include ${aws:username}, ${aws:userid}, ${aws:accountid}, and ${aws:region}.      
->Example of Policy Variables:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:ListBucket",
      "Resource": "arn:aws:s3:::example-bucket-${aws:username}"
    }
  ]
}
  - In this example, the policy allows the ListBucket action on an S3 bucket that is specific to the IAM user's username.   
->Tags in IAM Policies:
  - Tags are key-value pairs that can be attached to AWS resources and IAM entities (users, groups, roles).
  - Tags can be used in IAM policies to control access based on the presence or value of specific tags.
    - This allows for more granular and flexible access control based on resource or user attributes.       
->Example of Using Tags in Policies:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "ec2:StartInstances",
      "Resource": "arn:aws:ec2:region:account-id:instance/*",
      "Condition": {
        "StringEquals": {
          "ec2:ResourceTag/Environment": "Production"
        }
      }
    }
  ]
}
  - In this example, the policy allows the StartInstances action on EC2 instances that are tagged with Environment=Production.      


#IAM Roles VS Resource-Based Policies:
--------------------------------------
->IAM Roles:
  - IAM roles are AWS identities with specific permissions that can be assumed by trusted entities, such as IAM users, applications, or AWS services.
  - Roles do not have long-term credentials; instead, they provide temporary security credentials when assumed.
  - Roles are commonly used to grant permissions to AWS services to perform actions on your behalf or to allow cross-account access.    
->Resource-Based Policies:
  - Resource-based policies are policies that are attached directly to AWS resources, such as S3 buckets, SNS topics, or SQS queues.
  - These policies specify who (which users or roles) can access the resource and what actions they can perform on it.
  - Resource-based policies are useful for granting cross-account access, allowing users from different AWS accounts to access resources securely.    
->Key Differences:
  1)Attachment:
    - IAM Roles: Policies are attached to the role itself.
    - Resource-Based Policies: Policies are attached directly to the resource.   
  2)Use Cases:
    - IAM Roles: Used for granting permissions to AWS services, applications, or cross-account access.
    - Resource-Based Policies: Used for controlling access to specific resources, often for cross-account scenarios.   
  3)Trust Relationships:
    - IAM Roles: Require a trust policy that defines which entities can assume the role.
    - Resource-Based Policies: Do not require a trust policy; access is controlled through the resource policy itself.      
->When to Use Each:
  - Use IAM roles when you need to grant permissions to AWS services, applications, or for cross-account access.
  - Use resource-based policies when you need to control access to specific resources, especially in cross-account scenarios.   

# IAM Access Analyzer:
-----------------------
->Overview:
  - IAM Access Analyzer is a feature that helps you identify resources in your AWS environment that are shared with external entities.
  - It analyzes resource-based policies to determine if any resources are accessible from outside your AWS account. 
->Key Features:
  - Automated Analysis: Continuously monitors and analyzes resource policies to identify potential security risks.  
    - Findings: Generates findings that highlight resources that are accessible from outside your account, along with details about the access. 
    - Policy Validation: Helps you validate resource policies to ensure they adhere to best practices and do not unintentionally expose resources.  
->Use Cases:
  - Identifying unintended access to resources. 
    - Ensuring compliance with security policies and regulations.   
    - Validating resource policies during development and deployment.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#Advanced IAM Policy Concepts:
------------------------------


#IAM Policy -NotAction with Allow:
----------------------------------
->Overview:
  - The NotAction element in an IAM policy allows you to specify actions that are excluded from the permissions granted by the policy.
  - When used with an Allow effect, it grants permission for all actions except those specified in the NotAction element. 
->Example of NotAction with Allow:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "NotAction": [
        "s3:DeleteObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::example-bucket/*"
    }
  ]
}
  - In this example, the policy allows all actions on objects in the specified S3 bucket except for DeleteObject and PutObject.   
->Use Cases:
  - Granting broad permissions while restricting specific sensitive actions.
  - Simplifying policy management by allowing all actions except a few, rather than listing all allowed actions explicitly.

#IAM policy -NotAction with Deny:
----------------------------------
->Overview:
  - The NotAction element can also be used with a Deny effect in an IAM policy.
  - When used with Deny, it denies permission for all actions except those specified in the NotAction element.  
->Example of NotAction with Deny:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "NotAction": [
        "ec2:DescribeInstances",
        "ec2:DescribeVolumes"
      ],
      "Resource": "*"
    }
  ]
}
  - In this example, the policy denies all actions on all resources except for DescribeInstances and DescribeVolumes.   
->Use Cases:
  - Restricting access broadly while allowing specific read-only actions.
  - Implementing security controls that prevent most actions while permitting essential operations.

#principle Options in IAM policies:
------------------------------------
->Overview:
  - The Principal element in an IAM policy specifies the AWS accounts, users, roles, or services that are allowed or denied access to a resource.
  - It is primarily used in resource-based policies to define who can access the resource.  
->Types of Principals:
  1)AWS Account: Specifies an entire AWS account as the principal.
    - Example: "Principal": { "AWS": "arn:aws:iam::123456789012:root" }   
  2)IAM User or Role: Specifies a specific IAM user or role as the principal.
    - Example: "Principal": { "AWS": "arn:aws:iam::123456789012:user/ExampleUser" }
  3)AWS Service: Specifies an AWS service as the principal, allowing that service to access the resource.
    - Example: "Principal": { "Service": "ec2.amazonaws.com" }  
->Example of Principal in a Resource-Based Policy:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:user/ExampleUser"
      },
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::example-bucket/*"
    }
  ]
}
  - In this example, the policy allows the specified IAM user to perform the GetObject action on objects in the specified S3 bucket.    
->Use Cases:
  - Granting access to specific users, roles, or services for resource-based policies.
  - Implementing cross-account access by specifying principals from different AWS accounts.

#IAM Condition Operators Deep Dive:
-----------------------------------
->Overview:
  - IAM condition operators are used in the Condition element of an IAM policy to define specific criteria that must be met for the policy to take effect.
  - They allow you to create fine-grained access controls based on various attributes, such as IP addresses, dates, and resource tags.  
->Common Condition Operators:
  1)StringEquals: Checks if a string value matches the specified value exactly.
    - Example: "StringEquals": { "aws:username": "john_doe" }
  2)NumericLessThan: Checks if a numeric value is less than the specified value.
    - Example: "NumericLessThan": { "aws:MultiFactorAuthAge": "300" }
  3)Bool: Checks if a boolean value is true or false.
    - Example: "Bool": { "aws:MultiFactorAuthPresent": "true" } 
  4)IpAddress: Checks if the request originates from a specific IP address or range.
    - Example: "IpAddress": { "aws:SourceIp": "203.0.113.0/24" }  
  5)DateGreaterThan: Checks if the current date is greater than the specified date.
    - Example: "DateGreaterThan": { "aws:CurrentTime": "2023-01-01T00:00:00Z" }  
->Example of Using Condition Operators:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:ListBucket",
      "Resource": "arn:aws:s3:::example-bucket",
      "Condition": {
        "IpAddress": {
          "aws:SourceIp": "203.0.113.0/24" 
        },
        "Bool": {
          "aws:MultiFactorAuthPresent": "true"
        } 
      }
    }
  ]
}
  - In this example, the policy allows the ListBucket action on the specified S3 bucket only if the request originates from the IP address range  
   203.0.113.0/24 and the user has authenticated with multi-factor authentication (MFA).
->Best Practices:
  - Use condition operators to implement the principle of least privilege, granting access only under specific conditions.
  - Regularly review and update conditions to ensure they align with your security policies and requirements. 
  - Test policies with conditions in a safe environment to verify they behave as expected before deploying them in production.  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
